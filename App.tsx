import React, { useState, useCallback, useEffect } from 'react';
import { Node, useNodesState, useEdgesState } from 'reactflow';
import { Report, Plan, ChatMessage, CustomNode } from './types';
import { runCoordinatorPlanner, runAgentTask } from './services/agentService';
import { runWorkflow as runControlFlowWorkflow } from './services/apiService'; // Updated import
import WorkflowCanvas from './components/WorkflowCanvas';
import SidePanel from './components/SidePanel';
import ReportDisplay from './components/ReportDisplay';
import PlayIcon from './components/icons/PlayIcon';
import DocumentTextIcon from './components/icons/DocumentTextIcon';
import AgentTraceModal from './components/AgentTraceModal';
import { useStore } from './store';
import Notification from './components/Notification';

type NotificationType = {
  message: string;
  type: 'success' | 'error';
};

const App: React.FC = () => {
  const [nodes, setNodes, onNodesChange] = useNodesState<CustomNode[]>([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [chatMessages, setChatMessages] = useState<ChatMessage[]>([]);
  const [isRunning, setIsRunning] = useState<boolean>(false);
  const [finalReport, setFinalReport] = useState<Report | null>(null);
  const [isReportVisible, setIsReportVisible] = useState<boolean>(false);
  const [selectedNodeForTrace, setSelectedNodeForTrace] = useState<CustomNode | null>(null);
  const [notification, setNotification] = useState<NotificationType | null>(null);

  const { executionEngine, controlFlowProvider, customBaseUrl } = useStore();

  useEffect(() => {
    const welcomeMessage: ChatMessage = {
      id: `msg-${Date.now()}`,
      sender: 'ai',
      content: "Welcome to FINTEL! Select an engine and provider, then describe the financial analysis you need.",
      timestamp: new Date().toISOString(),
    };
    setChatMessages([welcomeMessage]);
  }, []);

  const addChatMessage = (sender: 'user' | 'ai', content: string) => {
    setChatMessages(prev => [
      ...prev,
      { id: `msg-${Date.now()}`, sender, content, timestamp: new Date().toISOString() },
    ]);
  };

  const setAndNotifyError = (errorMessage: string) => {
    addChatMessage('ai', `SYSTEM ERROR: ${errorMessage}`);
    setNotification({ message: errorMessage.length > 100 ? `${errorMessage.substring(0, 97)}...` : errorMessage, type: 'error' });
  };

  const generateGeminiWorkflow = useCallback(async (query: string) => {
    // This function remains for the visual, in-browser Gemini demonstration
    // It is assumed to be configured via a separate, secure process if used in production
    // For this project, it's a comparative architecture
    try {
      addChatMessage('ai', "Initializing Gemini (Visual) Engine...");
      const { plan, analysis } = await runCoordinatorPlanner(query);
      addChatMessage('ai', `Coordinator Plan: "${analysis}"`);
      // ... (visual graph generation logic remains the same)
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "An unknown error occurred.";
      setAndNotifyError(errorMessage);
    }
  }, [setNodes, setEdges]);
  
  const runPythonWorkflow = useCallback(async (query: string) => {
    addChatMessage('ai', `Executing with ControlFlow via '${controlFlowProvider}' provider...`);
    const runningNode: CustomNode = {
      id: 'controlflow_runner',
      type: 'agent',
      position: { x: 150, y: 150 },
      data: {
        label: `ControlFlow (${controlFlowProvider})`,
        details: 'Orchestrating agents in Python...',
        status: 'running',
      },
    };
    setNodes([runningNode]);
    setEdges([]);

    try {
      const report = await runControlFlowWorkflow(query, controlFlowProvider, customBaseUrl);
      setFinalReport(report);
      setIsReportVisible(true);
      addChatMessage('ai', 'ðŸŽ‰ Report generated by ControlFlow Engine!');
      setNotification({ message: 'Python backend finished successfully!', type: 'success' });
      setNodes(nds => nds.map(n => n.id === 'controlflow_runner' ? { ...n, data: { ...n.data, status: 'success', result: "Completed." } } : n));
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "An unknown error occurred.";
      setAndNotifyError(errorMessage);
      setNodes(nds => nds.map(n => n.id === 'controlflow_runner' ? { ...n, data: { ...n.data, status: 'failure', error: errorMessage } } : n));
    }
  }, [setNodes, setEdges, controlFlowProvider, customBaseUrl]);

  const handleSendMessage = useCallback(async (query: string) => {
    addChatMessage('user', query);
    setIsRunning(true);
    setFinalReport(null);
    setIsReportVisible(false);
    
    if (executionEngine === "ControlFlow (Python)") {
      await runPythonWorkflow(query);
    } else {
      await generateGeminiWorkflow(query);
    }
    
    setIsRunning(false);
  }, [executionEngine, runPythonWorkflow, generateGeminiWorkflow]);

  const handleRunWorkflowClick = useCallback(() => {
    if (executionEngine === "Gemini (Visual)") {
      // Logic to run the visual workflow would go here
      // For now, it's a placeholder as we focus on the Python backend
      setNodes(nds => nds.map(n => n.type === 'agent' ? { ...n, data: { ...n.data, status: 'running' } } : n));
      // ... runAgentTask logic would follow
    }
  }, [executionEngine, nodes]);


  return (
    <div className="flex flex-col h-full">
      <header className="text-center py-4 border-b border-brand-border flex-shrink-0">
        <h1 className="text-2xl font-bold text-white">FINTEL</h1>
        <p className="text-sm text-brand-text-secondary">Flexible Agentic Environment</p>
      </header>

      <div className="flex-grow flex flex-row overflow-hidden">
        <SidePanel
          chatMessages={chatMessages}
          onSendMessage={handleSendMessage}
          isLoading={isRunning}
        />

        <main className="flex-grow flex flex-col relative bg-brand-bg">
          <div className="absolute top-4 right-4 z-10 flex items-center">
            {executionEngine === 'Gemini (Visual)' && (
              <button
                onClick={handleRunWorkflowClick}
                disabled={isRunning || nodes.length === 0}
                className="flex items-center justify-center px-6 py-3 bg-brand-success text-white font-semibold rounded-md hover:bg-green-500 disabled:bg-brand-text-secondary disabled:cursor-not-allowed"
              >
                <PlayIcon className="w-5 h-5 mr-2" />
                Run Visual Workflow
              </button>
            )}
            {finalReport && (
              <button
                onClick={() => setIsReportVisible(true)}
                className="flex items-center justify-center px-6 py-3 bg-brand-primary text-white font-semibold rounded-md hover:bg-brand-secondary ml-4"
              >
                <DocumentTextIcon className="w-5 h-5 mr-2" />
                View Report
              </button>
            )}
          </div>
          <WorkflowCanvas
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onNodeDoubleClick={() => {}}
          />
        </main>
      </div>

      {notification && <Notification message={notification.message} type={notification.type} onClose={() => setNotification(null)} />}
      {finalReport && isReportVisible && <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center" onClick={() => setIsReportVisible(false)}><div className="w-full max-w-4xl h-[90vh] bg-brand-surface rounded-lg shadow-2xl overflow-y-auto" onClick={e => e.stopPropagation()}><ReportDisplay report={finalReport} /></div></div>}
      {selectedNodeForTrace && <AgentTraceModal node={selectedNodeForTrace} onClose={() => setSelectedNodeForTrace(null)} />}
    </div>
  );
};

export default App;
